// Signature file for parser generated by fsyacc
#light "off"
module Parser
type token = 
  | ALIGN_EQ_NAT of (string)
  | OFFSET_EQ_NAT of (string)
  | STORE of (TokenTypes.STOREType)
  | LOAD of (TokenTypes.LOADType)
  | CONVERT of (Ast.instr')
  | COMPARE of (Ast.instr')
  | TEST of (Ast.instr')
  | BINARY of (Ast.instr')
  | UNARY of (Ast.instr')
  | CONST of (TokenTypes.CONSTType)
  | VALUE_TYPE of (Types.value_type)
  | VAR of (string)
  | STRING of (string)
  | FLOAT of (string)
  | INT of (string)
  | NAT of (string)
  | EOF
  | INPUT
  | OUTPUT
  | ASSERT_RETURN
  | ASSERT_RETURN_CANONICAL_NAN
  | ASSERT_RETURN_ARITHMETIC_NAN
  | ASSERT_TRAP
  | ASSERT_EXHAUSTION
  | ASSERT_MALFORMED
  | ASSERT_INVALID
  | ASSERT_SOFT_INVALID
  | ASSERT_UNLINKABLE
  | SCRIPT
  | REGISTER
  | INVOKE
  | GET
  | MODULE
  | BIN
  | QUOTE
  | TABLE
  | ELEM
  | MEMORY
  | DATA
  | OFFSET
  | IMPORT
  | EXPORT
  | FUNC
  | START
  | TYPE
  | PARAM
  | RESULT
  | LOCAL
  | GLOBAL
  | UNREACHABLE
  | CURRENT_MEMORY
  | GROW_MEMORY
  | GET_LOCAL
  | SET_LOCAL
  | TEE_LOCAL
  | GET_GLOBAL
  | SET_GLOBAL
  | CALL
  | CALL_INDIRECT
  | RETURN
  | NOP
  | DROP
  | BLOCK
  | END
  | IF
  | THEN
  | ELSE
  | SELECT
  | LOOP
  | BR
  | BR_IF
  | BR_TABLE
  | ANYFUNC
  | MUT
  | LPAR
  | RPAR
type tokenId = 
    | TOKEN_ALIGN_EQ_NAT
    | TOKEN_OFFSET_EQ_NAT
    | TOKEN_STORE
    | TOKEN_LOAD
    | TOKEN_CONVERT
    | TOKEN_COMPARE
    | TOKEN_TEST
    | TOKEN_BINARY
    | TOKEN_UNARY
    | TOKEN_CONST
    | TOKEN_VALUE_TYPE
    | TOKEN_VAR
    | TOKEN_STRING
    | TOKEN_FLOAT
    | TOKEN_INT
    | TOKEN_NAT
    | TOKEN_EOF
    | TOKEN_INPUT
    | TOKEN_OUTPUT
    | TOKEN_ASSERT_RETURN
    | TOKEN_ASSERT_RETURN_CANONICAL_NAN
    | TOKEN_ASSERT_RETURN_ARITHMETIC_NAN
    | TOKEN_ASSERT_TRAP
    | TOKEN_ASSERT_EXHAUSTION
    | TOKEN_ASSERT_MALFORMED
    | TOKEN_ASSERT_INVALID
    | TOKEN_ASSERT_SOFT_INVALID
    | TOKEN_ASSERT_UNLINKABLE
    | TOKEN_SCRIPT
    | TOKEN_REGISTER
    | TOKEN_INVOKE
    | TOKEN_GET
    | TOKEN_MODULE
    | TOKEN_BIN
    | TOKEN_QUOTE
    | TOKEN_TABLE
    | TOKEN_ELEM
    | TOKEN_MEMORY
    | TOKEN_DATA
    | TOKEN_OFFSET
    | TOKEN_IMPORT
    | TOKEN_EXPORT
    | TOKEN_FUNC
    | TOKEN_START
    | TOKEN_TYPE
    | TOKEN_PARAM
    | TOKEN_RESULT
    | TOKEN_LOCAL
    | TOKEN_GLOBAL
    | TOKEN_UNREACHABLE
    | TOKEN_CURRENT_MEMORY
    | TOKEN_GROW_MEMORY
    | TOKEN_GET_LOCAL
    | TOKEN_SET_LOCAL
    | TOKEN_TEE_LOCAL
    | TOKEN_GET_GLOBAL
    | TOKEN_SET_GLOBAL
    | TOKEN_CALL
    | TOKEN_CALL_INDIRECT
    | TOKEN_RETURN
    | TOKEN_NOP
    | TOKEN_DROP
    | TOKEN_BLOCK
    | TOKEN_END
    | TOKEN_IF
    | TOKEN_THEN
    | TOKEN_ELSE
    | TOKEN_SELECT
    | TOKEN_LOOP
    | TOKEN_BR
    | TOKEN_BR_IF
    | TOKEN_BR_TABLE
    | TOKEN_ANYFUNC
    | TOKEN_MUT
    | TOKEN_LPAR
    | TOKEN_RPAR
    | TOKEN_end_of_input
    | TOKEN_error
type nonTerminalId = 
    | NONTERM__startscript
    | NONTERM__startscript1
    | NONTERM__startmodule1
    | NONTERM_name
    | NONTERM_string_list
    | NONTERM_value_type_list
    | NONTERM_elem_type
    | NONTERM_global_type
    | NONTERM_func_type
    | NONTERM_func_sig
    | NONTERM_table_sig
    | NONTERM_memory_sig
    | NONTERM_limits
    | NONTERM_type_use
    | NONTERM_literal
    | NONTERM_var
    | NONTERM_var_list
    | NONTERM_bind_var_opt
    | NONTERM_bind_var
    | NONTERM_labeling_opt
    | NONTERM_labeling_end_opt
    | NONTERM_offset_opt
    | NONTERM_align_opt
    | NONTERM_instr
    | NONTERM_plain_instr
    | NONTERM_call_instr
    | NONTERM_call_instr_sig
    | NONTERM_call_instr_params
    | NONTERM_call_instr_results
    | NONTERM_block_instr
    | NONTERM_block_sig
    | NONTERM_block
    | NONTERM_expr
    | NONTERM_expr1
    | NONTERM_call_expr_sig
    | NONTERM_call_expr_params
    | NONTERM_call_expr_results
    | NONTERM_if_block
    | NONTERM_if_
    | NONTERM_instr_list
    | NONTERM_expr_list
    | NONTERM_const_expr
    | NONTERM_func
    | NONTERM_func_fields
    | NONTERM_func_fields_import
    | NONTERM_func_fields_import_result
    | NONTERM_func_fields_body
    | NONTERM_func_result_body
    | NONTERM_func_body
    | NONTERM_offset
    | NONTERM_elem
    | NONTERM_table
    | NONTERM_table_fields
    | NONTERM_data
    | NONTERM_memory
    | NONTERM_memory_fields
    | NONTERM_global_
    | NONTERM_global_fields
    | NONTERM_import_desc
    | NONTERM_import
    | NONTERM_inline_import
    | NONTERM_export_desc
    | NONTERM_export
    | NONTERM_inline_export
    | NONTERM_type_
    | NONTERM_type_def
    | NONTERM_start
    | NONTERM_module_fields
    | NONTERM_module_fields1
    | NONTERM_module_var_opt
    | NONTERM_module_
    | NONTERM_inline_module
    | NONTERM_inline_module1
    | NONTERM_script_var_opt
    | NONTERM_script_module
    | NONTERM_action
    | NONTERM_assertion
    | NONTERM_cmd
    | NONTERM_cmd_list
    | NONTERM_meta
    | NONTERM_const_
    | NONTERM_const_list
    | NONTERM_script
    | NONTERM_script1
    | NONTERM_module1
/// This function maps tokens to integer indexes
val tagOfToken: token -> int

/// This function maps integer indexes to symbolic token ids
val tokenTagToTokenId: int -> tokenId

/// This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
val prodIdxToNonTerminal: int -> nonTerminalId

/// This function gets the name of a token as a string
val token_to_string: token -> string
val script : (Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> token) -> Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> (Script.script) 
val script1 : (Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> token) -> Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> (Script.script) 
val module1 : (Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> token) -> Microsoft.FSharp.Text.Lexing.LexBuffer<'cty> -> (Script.var option * Script.definition) 
